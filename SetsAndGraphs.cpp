#include "SetsAndGraphs.h"

using namespace std;

/** Функция нахождения пересечения двух множеств.
 *  Аргументы функции - два множества: A и B.
 *  Функция возвращает множество C.
 */
Set setIntersection(Set A, Set B)
{
    Set C; ///выделение памяти под пересечение

    if (A.empty() || B.empty()) ///если одно из множеств пустое
        return C;               ///возвращаем пустое множество

    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого множества
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго множества
                {
                    if (A.at(i) == B.at(j)) ///если элементы равны
                        C.push_back(A.at(i)); ///добавляем их значение в пересечение
                }
        }

    sort(C.begin(), C.end()); ///сортировка полученного множества
    return C;
}

/** Функция нахождения разности двух множеств.
 *  Аргументы функции - два множества: A и B.
 *  Функция возвращает множество R.
 */
Set setDifference(Set A, Set B)
{
    Set R; ///выделение памяти под разность

    if (A.empty()) ///если первое множество пустое
        return R;  ///возвращаем пустое множество
    if (B.empty()) ///если второе множество пустое
        return A;  ///возвращаем первое множество

    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого множества
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго множества
                {
                    if (A.at(i) != B.at(j)) ///если элементы не равны
                        {
                            if (!contains(R, A.at(i))) ///проверяем, содержится ли элемент a в разности
                                if (!contains(B, A.at(i))) ///если нет, то проверяем, содержится ли элемент b в разности
                                    R.push_back(A.at(i)); ///если нет, то добавляем его в разность
                        }
                }
        }

    sort(R.begin(), R.end()); ///сортировка полученного множества
    return R;
}

/** Функция нахождения симметрической разности двух множеств.
 *  Аргументы функции - два множества: A и B.
 *  Функция возвращает множество S.
 */
Set setSymDiff(Set A, Set B)
{
    Set S; ///выделение памяти под объединение

    if (A.empty()) ///если первое множество пустое
        return B;  ///возвращаем второе множество
    if (B.empty()) ///если второе множество пустое
        return A;  ///возвращаем первое множество

    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого множества
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго множества
                {
                    if (A.at(i) != B.at(j)) ///если элементы не равны
                        {
                            if (!contains(S, A.at(i)) && !contains(B, A.at(i))) ///то проверяем, содержится ли элемент a в симметрической разности и в множестве B
                                S.push_back(A.at(i)); ///если нет, то добавляем его
                            if (!contains(S, B.at(i)) && !contains(A, B.at(i))) ///проверяем, содержится ли элемент b в симметрической разности и в множестве A
                                S.push_back(B.at(i)); ///если нет, то добавляем его
                        }
                }
        }

    sort(S.begin(), S.end()); ///сортировка полученного множества
    return S;
}

/** Функция нахождения объединения двух множеств.
 *  Аргументы функции - два множества: A и B.
 *  Функция возвращает множество D.
 */
Set setUnion(Set A, Set B)
{
    Set D; ///выделение памяти под объединение

    if (A.empty() && B.empty()) ///если оба множества пустые
        return D; ///возвращаем пустое множество
    if (A.empty()) ///если множество A - пустое
        return B;  ///возвращаем множество B
    if (B.empty()) ///если множество B - пустое
        return A;  ///возвращаем множество A

    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого множества
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго множества
                {
                    if (A.at(i) != B.at(j)) ///если элементы не равны
                        {
                            if (!contains(D, A.at(i))) ///то проверяем, содержится ли элемент a в объединении
                                D.push_back(A.at(i));  ///если нет, то добавляем его в объединение
                            if (!contains(D, B.at(j))) ///проверяем, содержится ли элемент b в объединении
                                D.push_back(B.at(j));  ///если нет, то добавляем его в объединение
                        }
                    else
                        if (!contains(D, A.at(i)))
                            D.push_back(A.at(i));
                }
        }

    sort(D.begin(), D.end()); ///сортировка полученного множества
    return D;
}

///-------------------------------------------------------------------------------------------
///-------------------------------------------------------------------------------------------
///-------------------------------------------------------------------------------------------
///-------------------------------------------------------------------------------------------
///-------------------------------------------------------------------------------------------

/** Функция нахождения пересечения двух графиков.
 *  Аргументы функции - два графика: A и B.
 *  Функция возвращает график C.
 */
Graph graphIntersection(Graph A, Graph B)
{
    Graph C; ///выделение памяти под пересечение

    if (A.empty() || B.empty()) ///если одно из графиков пустой
        return C;               ///возвращаем пустой график

    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого графика
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго графика
                {
                    if (A.at(i) == B.at(j)) ///если элементы равны
                        C.push_back(A.at(i)); ///добавляем их значение в пересечение
                }
        }

    sort(C.begin(), C.end()); ///сортировка полученного графика
    return C;
}

/** Функция нахождения разности двух графиков.
 *  Аргументы функции - два графика: A и B.
 *  Функция возвращает график R.
 */
Graph graphDifference(Graph A, Graph B)
{
    Graph R; ///выделение памяти под разность

    if (A.empty()) ///если первое график пустой
        return R;  ///возвращаем пустой график
    if (B.empty()) ///если второе график пустой
        return A;  ///возвращаем первое график

    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого графика
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго графика
                {
                    if (A.at(i) != B.at(j)) ///если элементы не равны
                        {
                            if (!contains(R, A[i])) ///проверяем, содержится ли элемент a в разности
                                if (!contains(B, A.at(i))) ///если нет, то проверяем, содержится ли элемент b в разности
                                    R.push_back(A.at(i)); ///если нет, то добавляем его в разность
                        }
                }
        }

    sort(R.begin(), R.end()); ///сортировка полученного графика
    return R;
}

/** Функция нахождения симметрической разности двух графиков.
 *  Аргументы функции - два графика: A и B.
 *  Функция возвращает график S.
 */
Graph graphSymDiff(Graph A, Graph B)
{
    Graph S; ///выделение памяти под объединение

    if (A.empty()) ///если первое график пустой
        return B;  ///возвращаем второе график
    if (B.empty()) ///если второе график пустой
        return A;  ///возвращаем первое график

    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого графика
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго графика
                {
                    if (A.at(i) != B.at(j)) ///если элементы не равны
                        {
                            if (!contains(S, A.at(i)) && !contains(B, A.at(i))) ///то проверяем, содержится ли элемент a в симметрической разности и в множестве B
                                S.push_back(A.at(i)); ///если нет, то добавляем его
                            if (!contains(S, B.at(i)) && !contains(A, B.at(i))) ///проверяем, содержится ли элемент b в симметрической разности и в множестве A
                                S.push_back(B.at(i)); ///если нет, то добавляем его
                        }
                }
        }

    sort(S.begin(), S.end()); ///сортировка полученного графика
    return S;
}

/** Функция нахождения объединения двух графиков.
 *  Аргументы функции - два графика: A и B.
 *  Функция возвращает график D.
 */
Graph graphUnion(Graph A, Graph B)
{
    Graph D; ///выделение памяти под объединение

    if (A.empty() && B.empty()) ///если оба графика пустые
        return D; ///возвращаем пустой график
    if (A.empty()) ///если график A - пустой
        return B;  ///возвращаем график B
    if (B.empty()) ///если график B - пустой
        return A;  ///возвращаем график A

    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого графика
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго графика
                {
                    if (A.at(i) != B.at(j)) ///если элементы не равны
                        {
                            if (!contains(D, A.at(i))) ///то проверяем, содержится ли элемент a в объединении
                                D.push_back(A.at(i));  ///если нет, то добавляем его в объединение
                            if (!contains(D, B.at(j))) ///проверяем, содержится ли элемент b в объединении
                                D.push_back(B.at(j));  ///если нет, то добавляем его в объединение
                        }
                    else if (!contains(D, A.at(i)))
                        D.push_back(A.at(i));
                }
        }

    sort(D.begin(), D.end()); ///сортировка полученного графика
    return D;
}

/** Функция нахождения инверсии графика.
 *  Аргумент функции - график А.
 *  Функция возвращает график I.
 */
Graph graphInversion(Graph A)
{
    Graph I(A.size()); ///создание графика с размером, равным размеру исходного графика
    pair<int, int> temp; ///вспомогательная переменная для хранения инверсии пары чисел
    for (size_t i = 0; i < A.size(); i++) ///обход по всем элементам первого графика
        {
            ///создание и добавление в график I инверсии i-ой пары графика A
            temp.first = A[i].second;
            temp.second = A[i].first;
            I[i] = temp;
        }
    return I;
}

/** Функция нахождения композиции двух графиков.
 *  Аргументы функции - два графика: A и B.
 *  Функция возвращает график C.
 */
Graph graphComposition(Graph A, Graph B)
{
    Graph C; ///обявление графика - композиции
    pair<int, int> temp; ///вспомогательная переменная для хранения пары чисел
    for (size_t i = 0; i < A.size(); i ++) ///обход по всем элементам первого графика
        {
            for (size_t j = 0; j < B.size(); j++) ///обход по всем элементам второго графика
                {
                    if (A[i].second == B[j].first) ///если вторая компонента i-й пары равна первой компоненте j-й пары
                        {
                            ///создание и добавление в композицию пары, состоящей из первой компоненты i-ой пары и второй компоненты j-ой пары
                            temp.first = A[i].first;
                            temp.second = B[j].second;
                            if (!contains(C, temp))
                                C.push_back(temp);
                        }
                }
        }
    return C;
}
